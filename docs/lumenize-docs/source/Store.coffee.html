<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* &lt;CoffeeScript&gt;

{utils, Time} = require(&#39;tztime&#39;)
functions = require(&#39;./functions&#39;).functions  # !TODO: Do we need this here?
{arrayOfMaps_To_CSVStyleArray, csvStyleArray_To_ArrayOfMaps} = require(&#39;./dataTransform&#39;)  # !TODO: Do we need this here?
JSON = require(&#39;JSON2&#39;)

class Store
&lt;/CoffeeScript&gt; */
<span id='Lumenize-Store-method-constructor'><span id='Lumenize-Store-cfg-defaultValues'><span id='Lumenize-Store-cfg-idField'><span id='Lumenize-Store-cfg-validToField'><span id='Lumenize-Store-cfg-validFromField'><span id='Lumenize-Store-cfg-uniqueIDField'><span id='Lumenize-Store'>  /**
</span></span></span></span></span></span></span>   * @class Lumenize.Store
   * 
   * __An efficient, in-memory, datastore for snapshot data.__
   * 
   * Note, this store takes advantage of JavaScript&#39;s prototype inheritance to store snapshots in memory. Since the next snapshot might
   * only have one field different from the prior one, this saves a ton of space. There is some concern that this will
   * slow down certain operations because the interpreter has to search all fields in the current level before bumping up
   * to the next. However, there is some evidence that modern javascript implementations handle this very efficiently.
   * 
   * However, this choice means that each row in the snapshots array doesn&#39;t have all of the fields.
   * 
   * Store keeps track of all of the fields it has seen so you can flatten a row(s) if necessary.
   * 
   * 
   * @constructor
   * @param {Object} config See Config options for details.
   * @param {Object[]} [snapshots] Optional parameter allowing the population of the Store at instantiation.
   * @cfg {String} [uniqueIDField = &quot;ObjectID&quot;] Specifies the field that identifies unique entities (Default: &quot;ObjectID&quot;).
   * @cfg {String} [validFromField = &quot;_ValidFrom&quot;]
   * @cfg {String} [validToField = &quot;_ValidTo&quot;]
   * @cfg {String} [idField = &quot;_id&quot;]
   * @cfg {Object} [defaultValues = {}] In some datastores, null numeric fields may be assumed to be zero and null
   *   boolean fields may be assumed to be false. Lumenize makes no such assumption and will crash if a field value
   *   is missing. the defaultValues becomes the root of prototype inheritance hierarchy.
   * 
   */
/* &lt;CoffeeScript&gt;


    @config = utils.clone(@userConfig)
    unless @config.uniqueIDField?
      @config.uniqueIDField = &#39;ObjectID&#39;
    unless @config.validFromField?
      @config.validFromField = &#39;_ValidFrom&#39;
    unless @config.validToField?
      @config.validToField = &#39;_ValidTo&#39;
    unless @config.defaultValues?
      @config.defaultValues = {}
    @config.defaultValues[@config.validFromField] = new Time(1, Time.MILLISECOND).toString()
    unless @config.idField?
      @config.idField = &#39;_id&#39;


    @snapshots = []
    @lastValidFrom = new Time(1, Time.MILLISECOND).toString()

    @byUniqueID = {}
      # In the form:
      # {
      #   &#39;1234&#39;: {
      #     snapshots: [...],
      #     lastSnapshot: &lt;points to last snapshot for this uniqueID&gt;
      #   },
      #   &#39;7890&#39;: {
      #     ...
      #   },
      #   ...
      # }

    @addSnapshots(snapshots)


  addSnapshots: (snapshots) -&gt;
&lt;/CoffeeScript&gt; */
<span id='Lumenize-Store-method-addSnapshots'>    /**
</span>     * @method addSnapshots
     * @member Lumenize.Store
     *   Adds the snapshots to the Store
     * @param {Object} snapshots
     * @chainable
     * @return {Store} Returns this
     * 
     */
/* &lt;CoffeeScript&gt;
    snapshots = utils._.sortBy(snapshots, @config.validFromField)
    for s in snapshots
      uniqueID = s[@config.uniqueIDField]
      utils.assert(uniqueID?, &quot;Missing #{@config.uniqueIDField} field in submitted snapshot: \n&quot; + JSON.stringify(s, null, 2))

      dataForUniqueID = @byUniqueID[uniqueID]
      unless dataForUniqueID?
        # First time we&#39;ve seen this uniqueID
        dataForUniqueID =
          snapshots: []
          lastSnapshot: @config.defaultValues
        @byUniqueID[uniqueID] = dataForUniqueID

      validFrom = s[@config.validFromField]
      utils.assert(new Time(validFrom).toString() == validFrom, &#39;Invalid format for validFromField&#39;)  # !TODO: Soften this to allow for ending &#39;Z&#39; and other types
      utils.assert(validFrom &gt;= dataForUniqueID.lastSnapshot[@config.validFromField], &#39;validFromField must be &gt;= lastValidFrom for this entity&#39; ) # !TODO: Deal with out of order snapshots
      utils.assert(validFrom &gt;= @lastValidFrom, &#39;validFromField must be &gt;= lastValidFrom for the Store&#39;)

      validTo = s[@config.validTo]
      unless validTo?
        validTo = &#39;9999-01-01T00:00:00.000Z&#39;

      priorSnapshot = dataForUniqueID.lastSnapshot

      # Build new Snapshot
      newSnapshot = {}
      newSnapshot._previousValues = {}
      for key, value of s
        unless key in [@config.validFromField, @config.validToField, &#39;_previousValues&#39;, @config.uniqueIDField]
          unless value == priorSnapshot[key]
            newSnapshot[key] = value
            unless key in [@config.idField]

              if priorSnapshot[key]?
                newSnapshot._previousValues[key] = priorSnapshot[key]
              else
                newSnapshot._previousValues[key] = null

      newSnapshot[@config.uniqueIDField] = uniqueID
      newSnapshot[@config.validFromField] = validFrom
      newSnapshot[@config.validToField] = validTo
      newSnapshot.__proto__ = priorSnapshot

      # Update priorSnapshot
      priorSnapshot[@config.validToField] = validFrom
      # priorSnapshot._nextSnapshot = newSnapshot  # Adding link to next snapshot in case we want to do smart insertion later

      # Update metadata
      dataForUniqueID.lastSnapshot = newSnapshot
      @lastValidFrom = validFrom

      # Add the newSnapshot to the arrays
      @byUniqueID[uniqueID].snapshots.push(newSnapshot)
      @snapshots.push(newSnapshot)

    return this

  filtered: (filter) -&gt;
&lt;/CoffeeScript&gt; */
<span id='Lumenize-Store-method-filtered'>    /**
</span>     * @method filtered
     * @member Lumenize.Store
     *   Returns the subset of the snapshots that match the filter
     * @param {Function} filter
     * @return {Object[]} An array or snapshots. Note, they will not be flattened so they have references to their prototypes
     */
/* &lt;CoffeeScript&gt;
    result = []
    for s in @snapshots
      if filter(s)
        result.push(s)

    return result

  stateBoundaryCrossedFiltered: (field, values, valueToTheRightOfBoundary, forward = true, assumeNullIsLowest = true) -&gt;
&lt;/CoffeeScript&gt; */
<span id='Lumenize-Store-method-stateBoundaryCrossedFiltered'>    /**
</span>     * @method stateBoundaryCrossedFiltered
     * @member Lumenize.Store
     *   Returns the subset of the snapshots where the field transitions from the left of valueToTheRightOfBoundary to
     *   the right (inclusive)
     * @param {String} field
     * @param {String[]} values
     * @param {String} valueToTheRightOfBoundary
     * @param {Boolean} [forward = true] When true (the default), this will return the transitions from left to right
     *   However, if you set this to false, it will return the transitions right to left.
     * @param {Boolean} [assumeNullIsLowest = true] Set to false if you don&#39;t want to consider transitions out of null
     * @return {Object[]} An array or snapshots. Note, they will not be flattened so they have references to their prototypes
     */
/* &lt;CoffeeScript&gt;
    index = values.indexOf(valueToTheRightOfBoundary)
    utils.assert(index &gt;= 0, &quot;stateToTheRightOfBoundary must be in stateList&quot;)
    left = values.slice(0, index)
    if assumeNullIsLowest
      left.unshift(null)
    right = values.slice(index)
    if forward
      filter = (s) -&gt; s._previousValues.hasOwnProperty(field) and s._previousValues[field] in left and s[field] in right
    else
      filter = (s) -&gt; s._previousValues.hasOwnProperty(field) and s._previousValues[field] in right and s[field] in left

    return @filtered(filter)

  stateBoundaryCrossedFilteredBothWays: (field, values, valueToTheRightOfBoundary, assumeNullIsLowest = true) -&gt;
&lt;/CoffeeScript&gt; */
<span id='Lumenize-Store-method-stateBoundaryCrossedFilteredBothWays'>    /**
</span>     * @method stateBoundaryCrossedFilteredBothWays
     * @member Lumenize.Store
     *   Shortcut to stateBoundaryCrossedFiltered for when you need both directions
     * @param {String} field
     * @param {String[]} values
     * @param {String} valueToTheRightOfBoundary
     * @param {Boolean} [assumeNullIsLowest = true] Set to false if you don&#39;t want to consider transitions out of null
     * @return {Object} An object with two root keys: 1) forward, 2) backward. The values are the arrays that are returned
     *   from stateBoundaryCrossedFiltered
     */
/* &lt;CoffeeScript&gt;
    forward = @stateBoundaryCrossedFiltered(field, values, valueToTheRightOfBoundary, true, assumeNullIsLowest)
    backward = @stateBoundaryCrossedFiltered(field, values, valueToTheRightOfBoundary, false, assumeNullIsLowest)
    return {forward, backward}



exports.Store = Store
&lt;/CoffeeScript&gt; */</pre>
</body>
</html>
